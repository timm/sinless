<!DOCTYPE html>

<html>
<head>
  <title>sinless.py</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>sinless.py</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">&#x00a7;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">#!/usr/bin/env python3</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">&#x00a7;</a>
              </div>
              <p>vim: ts=2 sw=2 sts=2 et :</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-string">&quot;&quot;&quot;
This code tries to cure the following AI sins:
- AI tools, that require too much data, are hard to commission
- AI tools, that cannot explain themselves, do not permit transparency and accountability
- AI tools, that are needlessly complicated, waste CPU time and people time (and are hard to understand,
  test, and extend)
- AI tools, used off the shelf without tuning, are sub-optimal

To that end, we try:
- Use semi-supervised learning to reduce the commission costs (i.e. use fewer labels from the domain)
- Use symbolic AI tools that generate rules describing regions where concusions hold.
- Use epsilon domination to stop needlessly explore spurious details
- Use all the above in Hyperparameter optimizers so you can optimize the tool.

Does this solve all the problems of AI? Of course not.
But at least its a start. And as
St. Bernard of Clairvaux used to say:
&quot;A saint is not someone who never sins, 
but one who sins less and less frequently and gets up more and more quickly&quot;   

&quot;&quot;&quot;</span>
<span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> FunctionType <span class="hljs-keyword">as</span> fun
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps
<span class="hljs-keyword">import</span> re, sys, math, random, argparse, traceback
fr = random.random

CONFIG = <span class="hljs-built_in">dict</span>(    
  bins = (<span class="hljs-built_in">float</span>,<span class="hljs-number">.5</span>,   <span class="hljs-string">&quot;min bin size is n**bin&quot;</span>),    
  cohen= (<span class="hljs-built_in">float</span>,<span class="hljs-number">.35</span>,  <span class="hljs-string">&quot;ignore differences less than cohen*sd&quot;</span>),    
  depth= (<span class="hljs-built_in">int</span>,  <span class="hljs-number">5</span>,    <span class="hljs-string">&quot;dendogram depth&quot;</span>),     
  end  = (<span class="hljs-built_in">int</span>,  <span class="hljs-number">4</span>,    <span class="hljs-string">&quot;stopping criteria&quot;</span>),    
  far  = (<span class="hljs-built_in">float</span>,<span class="hljs-number">.9</span>,   <span class="hljs-string">&quot;where to find far samples&quot;</span>),      
  loud = (<span class="hljs-built_in">bool</span>, <span class="hljs-literal">False</span>,<span class="hljs-string">&quot;loud mode: print stacktrace on error&quot;</span>),    
  <span class="hljs-built_in">max</span>  = (<span class="hljs-built_in">int</span>,  <span class="hljs-number">500</span>,  <span class="hljs-string">&quot;max samples held  by `Nums`&quot;</span>),     
  p    = (<span class="hljs-built_in">int</span>,  <span class="hljs-number">2</span>,    <span class="hljs-string">&quot;co-efficient on distance equation&quot;</span>),    
  seed = (<span class="hljs-built_in">int</span>,  <span class="hljs-number">256</span>,  <span class="hljs-string">&quot;random number seed&quot;</span>),      
  todo = (<span class="hljs-built_in">str</span>,  <span class="hljs-string">&quot;&quot;</span>,   <span class="hljs-string">&quot;todo: function (to be run at start-up)&quot;</span>),     
  Todo = (<span class="hljs-built_in">str</span>, <span class="hljs-literal">False</span>, <span class="hljs-string">&quot;list available items for -t&quot;</span>))     

<span class="hljs-keyword">class</span> <span class="hljs-title class_">o</span>:
  <span class="hljs-string">&quot;Return a class can print itself (hiding &#x27;private&#x27; keys)&quot;</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">i, **d</span>)  : i.__dict__.update(d)
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">i</span>) : <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;{&quot;</span>+ <span class="hljs-string">&#x27;, &#x27;</span>.join(
    [<span class="hljs-string">f&quot;:<span class="hljs-subst">{k}</span> <span class="hljs-subst">{v}</span>&quot;</span> <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> i.__dict__.items() <span class="hljs-keyword">if</span>  k[<span class="hljs-number">0</span>] != <span class="hljs-string">&quot;_&quot;</span>])+<span class="hljs-string">&quot;}&quot;</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Distance</span>:
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sym</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dist</span>(<span class="hljs-params">i,x,y</span>):
      <span class="hljs-string">&quot;Distance: between two symbols&quot;</span>
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> x==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">and</span> y==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x==y <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>)

  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Num</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dist</span>(<span class="hljs-params">i,x,y</span>):
      <span class="hljs-string">&quot;Distance: between two numbers.&quot;</span>
      <span class="hljs-keyword">if</span> x==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">and</span> y==<span class="hljs-string">&quot;?&quot;</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
      <span class="hljs-keyword">if</span> x==<span class="hljs-string">&quot;?&quot;</span>: 
        y = i.norm(y); x = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> y &gt; <span class="hljs-number">0.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
      <span class="hljs-keyword">elif</span> y==<span class="hljs-string">&quot;?&quot;</span>: 
        x = i.norm(x); y = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>
      <span class="hljs-keyword">else</span>:
        x,y = i.norm(x), i.norm(y)
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(x - y)

  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cluster</span>(<span class="hljs-params">i</span>):
      <span class="hljs-string">&quot;Distance: Divide `d.rows` into a tree of  `depth`.&quot;</span>
      out = []
      <span class="hljs-keyword">def</span> <span class="hljs-title function_">div</span>(<span class="hljs-params">rows, depth</span>):
        <span class="hljs-keyword">if</span> depth &gt; i.my.depth  <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(rows) &lt; i.my.end:
          out.append(i.clone(rows))
        <span class="hljs-keyword">else</span>:
          left, right  = i.polarize(rows)
          div(left,  depth + <span class="hljs-number">1</span>)
          div(right, depth + <span class="hljs-number">1</span>)
      div(i.rows, <span class="hljs-number">1</span>)
      <span class="hljs-keyword">return</span> out

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dist</span>(<span class="hljs-params">i,r1,r2</span>):
        <span class="hljs-string">&quot;Distance: between two rows&quot;</span>
        d, n = <span class="hljs-number">0</span>, <span class="hljs-number">1E-32</span>
        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> i.x:
          inc = col.dist( r1.cells[col.at], r2.cells[col.at] )
          d  += inc**i.my.p
          n  +=<span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> (d/n)**(<span class="hljs-number">1</span>/i.my.p)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">faraway</span>(<span class="hljs-params">i, rows, r1</span>):
      <span class="hljs-string">&quot;Distance: to a remove row&quot;</span>
      random.shuffle(rows)
      rows = <span class="hljs-built_in">sorted</span>([(i.dist(r1,r2),r2) <span class="hljs-keyword">for</span> r2 <span class="hljs-keyword">in</span> rows[:<span class="hljs-number">128</span>]], key=first)
      <span class="hljs-keyword">return</span> rows[<span class="hljs-built_in">int</span>(i.my.far*<span class="hljs-built_in">len</span>(rows))]

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">polarize</span>(<span class="hljs-params">i,rows</span>):
      <span class="hljs-string">&quot;Distance: Separate rows via their distance to two distant points.&quot;</span>
      anywhere = random.choice(rows)
      _,north  = i.faraway(rows, anywhere)
      c,south  = i.faraway(rows, north)
      <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rows: 
        r.x = (i.dist(r,north)**<span class="hljs-number">2</span> + c**<span class="hljs-number">2</span> - i.dist(r,south)**<span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*c)
      rows  = <span class="hljs-built_in">sorted</span>(rows, key=<span class="hljs-keyword">lambda</span> row: row.x)
      mid   = <span class="hljs-built_in">len</span>(rows)//<span class="hljs-number">2</span>
      <span class="hljs-keyword">return</span> rows[:mid], rows[mid:]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Discretize</span>:
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">unsuper</span>(<span class="hljs-params">lst,big,iota</span>):
    <span class="hljs-string">&quot;&quot;&quot;Discretization: divide lst into bins of at least size 
    `big`, that span more than `iota`&quot;&quot;&quot;</span>
    lst  = <span class="hljs-built_in">sorted</span>(lst, key=first)
    x= lst[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    now  = o(lo=x, hi=x, n=<span class="hljs-number">0</span>, y=Sym())
    <span class="hljs-built_in">all</span>  = [now]
    <span class="hljs-keyword">for</span> i,(x,y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lst):
      <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(lst) - big:
        <span class="hljs-keyword">if</span> now.n &gt;= big:
           <span class="hljs-keyword">if</span> now.hi - now.lo &gt; iota:
             <span class="hljs-keyword">if</span> x != lst[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]:
               now = o(lo=x,hi=x,n=<span class="hljs-number">0</span>,y=Sym())
               <span class="hljs-built_in">all</span> += [now]
      now.n += <span class="hljs-number">1</span>
      now.hi = x
      now.y.add(y)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>
  
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">b4</span>):
    <span class="hljs-string">&quot;Discretization: merge adjacent bins if they do not reduce the variability.&quot;</span>
    j,tmp = <span class="hljs-number">0</span>,[]
    <span class="hljs-keyword">while</span> j &lt; <span class="hljs-built_in">len</span>(b4):
      a = b4[j]
      <span class="hljs-keyword">if</span> j &lt; <span class="hljs-built_in">len</span>(b4) - <span class="hljs-number">1</span>:
        b = b4[j+<span class="hljs-number">1</span>]
        cy = a.y.merge(b.y)
        <span class="hljs-keyword">if</span> cy.var()*<span class="hljs-number">.95</span> &lt;= (a.y.var()*a.n + b.y.var()*b.n)/(a.n + b.n):
           a = o(lo=a.lo, hi=b.hi, n=a.n+b.n, y=cy)
           j += <span class="hljs-number">1</span>
      tmp += [a]
      j += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> merge(tmp) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) &lt; <span class="hljs-built_in">len</span>(b4) <span class="hljs-keyword">else</span> b4

  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sym</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">discretize</span>(<span class="hljs-params">i,j,_</span>):
      <span class="hljs-string">&quot;Query: `Return values seen in  i` is good and `j` is bad&quot;</span>
      <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(i.has | j.has): 
        <span class="hljs-keyword">yield</span> o(at=i.at, name=i.txt, lo=x, hi=x, 
                best= i.has.get(x,<span class="hljs-number">0</span>), rest=j.has.get(x,<span class="hljs-number">0</span>))

  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Num</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">discretize</span>(<span class="hljs-params">i,j, my</span>):
      <span class="hljs-string">&quot;Query: `Return values seen in  i` is good and `j` is bad&quot;</span>
      best, rest = <span class="hljs-number">1</span>,<span class="hljs-number">0</span>
      xys=[(good,best) <span class="hljs-keyword">for</span> good <span class="hljs-keyword">in</span> i._<span class="hljs-built_in">all</span>] + [
           (bad, rest) <span class="hljs-keyword">for</span> bad  <span class="hljs-keyword">in</span> j._<span class="hljs-built_in">all</span>]
      n1,n2 = <span class="hljs-built_in">len</span>(i._<span class="hljs-built_in">all</span>), <span class="hljs-built_in">len</span>(j._<span class="hljs-built_in">all</span>)
      iota = my.cohen * (i.var()*n1 + j.var()*n2) / (n1 + n2)
      ranges = merge(unsuper(xys, <span class="hljs-built_in">len</span>(xys)**my.bins, iota))
      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ranges) &gt; <span class="hljs-number">1</span>:
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> ranges:
          <span class="hljs-keyword">yield</span> o(at=i.at, name=i.txt, lo=r.lo, hi=r.hi, 
                  best= r.y.has.get(best,<span class="hljs-number">0</span>), rest=r.y.has.get(rest,<span class="hljs-number">0</span>))

 
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Skip</span>(<span class="hljs-title class_ inherited__">o</span>):
  <span class="hljs-string">&quot;Column: Make something that ignores everything it sees.&quot;</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">i,_,n=<span class="hljs-number">0</span>,s=<span class="hljs-string">&quot;&quot;</span></span>): i.n,i.at,i.txt,i.w = <span class="hljs-number">0</span>,n,s,<span class="hljs-number">1</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">i,x</span>):  <span class="hljs-keyword">return</span>  x
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mid</span>(<span class="hljs-params">i</span>):    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;?&quot;</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">prep</span>(<span class="hljs-params">i,x</span>): <span class="hljs-keyword">return</span> x

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sym</span>(Distance,Discretize,o):
  <span class="hljs-string">&quot;Symbol counter.&quot;</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">i,my={},n=<span class="hljs-number">0</span>,s=<span class="hljs-string">&quot;&quot;</span></span>): 
    <span class="hljs-string">&quot;Creation&quot;</span>
    i.n,i.at,i.txt,i.has,i.w = <span class="hljs-number">0</span>,n,s,{},<span class="hljs-number">1</span>
    i.mode, i.most = <span class="hljs-literal">None</span>,<span class="hljs-number">0</span>

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">i,x,n=<span class="hljs-number">1</span></span>): 
    <span class="hljs-string">&quot;Update:  symbol counts.&quot;</span>
    <span class="hljs-keyword">if</span> x != <span class="hljs-string">&quot;?&quot;</span>: 
      i.n += n
      new = i.has[x] = n + i.has.get(x,<span class="hljs-number">0</span>)
      <span class="hljs-keyword">if</span> new &gt; i.most:
         i.most,i.mmode = new, x
    <span class="hljs-keyword">return</span> x
      
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">i,j</span>):
    <span class="hljs-string">&quot;Copy: merge two symbol counters&quot;</span>
    k = Sym(n=i.at, s=i.txt)
    <span class="hljs-keyword">for</span> x,n <span class="hljs-keyword">in</span> i.has.items(): k.add(x,n)
    <span class="hljs-keyword">for</span> x,n <span class="hljs-keyword">in</span> j.has.items(): k.add(x,n)
    <span class="hljs-keyword">return</span> k

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mid</span>(<span class="hljs-params">i</span>): 
    <span class="hljs-string">&quot;Query: Central tendency&quot;</span>
    <span class="hljs-keyword">return</span> i.mode

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">prep</span>(<span class="hljs-params">i,x</span>): 
    <span class="hljs-string">&quot;Creation: Coerce `x` to a string.&quot;</span>
    <span class="hljs-keyword">return</span> x

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">var</span>(<span class="hljs-params">i</span>):
    <span class="hljs-string">&quot;Query: variability&quot;</span>
    <span class="hljs-keyword">return</span> - <span class="hljs-built_in">sum</span>(v/i.n * math.log2(v/i.n) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> i.has.values())

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Num</span>(Distance,Discretize,o):
  <span class="hljs-string">&quot;&quot;&quot;Column: Numeric counters. This is a reservoir sampler;
   i.e. after a fixed number of items, new items replace older ones,
   selected at random.&quot;&quot;&quot;</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">i, my=o(<span class="hljs-params"><span class="hljs-built_in">max</span>=<span class="hljs-number">256</span></span>), n=<span class="hljs-number">0</span>, s=<span class="hljs-string">&quot;&quot;</span></span>):
    <span class="hljs-string">&quot;Creation&quot;</span>
    i.n, i.at, i.txt, i._<span class="hljs-built_in">all</span> =  <span class="hljs-number">0</span>, n, s, []
    i.old, i.<span class="hljs-built_in">max</span>, i.lo, i.hi = <span class="hljs-literal">True</span>, my.<span class="hljs-built_in">max</span>, <span class="hljs-number">1E32</span>, -<span class="hljs-number">1E32</span>  
    i.w= -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">in</span> s <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">i,x</span>): 
    <span class="hljs-string">&quot;&quot;&quot;Update: Keep a representative sample of the `x` values as
    well as the `lo` and `hi`  value  seen so far.&quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> x != <span class="hljs-string">&quot;?&quot;</span>:
      i.n += <span class="hljs-number">1</span>
      <span class="hljs-keyword">if</span> x &gt; i.hi: i.hi = x
      <span class="hljs-keyword">if</span> x &lt; i.lo: i.lo = x
      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(i._<span class="hljs-built_in">all</span>) &lt; i.<span class="hljs-built_in">max</span>: 
        i.old = <span class="hljs-literal">True</span>
        i._<span class="hljs-built_in">all</span> += [x]
      <span class="hljs-keyword">elif</span> r() &lt; i.<span class="hljs-built_in">max</span>/i.n: 
        i.old = <span class="hljs-literal">True</span>
        i._<span class="hljs-built_in">all</span>[<span class="hljs-built_in">int</span>(r()*<span class="hljs-built_in">len</span>(i._<span class="hljs-built_in">all</span>))] = x
    <span class="hljs-keyword">return</span>  x

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">i</span>):
    <span class="hljs-string">&quot;Query: Return the stored numbers, sorted.&quot;</span>
    <span class="hljs-keyword">if</span> i.old: i._<span class="hljs-built_in">all</span>.sort()
    i.old = <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> i._<span class="hljs-built_in">all</span>

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mid</span>(<span class="hljs-params">i</span>):  
    <span class="hljs-string">&quot;Query: mid point of the numbers.&quot;</span>
    <span class="hljs-keyword">return</span> i.per()

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">i,j</span>):
    <span class="hljs-string">&quot;Copy: merge two numeric counters&quot;</span>
    k = Num(n=i.at, s=i.txt)
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> i._<span class="hljs-built_in">all</span>: k.add(x)
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> j._<span class="hljs-built_in">all</span>: k.add(x)
    <span class="hljs-keyword">return</span> k

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">norm</span>(<span class="hljs-params">i,x</span>): 
    <span class="hljs-string">&quot;Query: return 0..1&quot;</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(i.hi - i.lo) &lt; <span class="hljs-number">1E-31</span> <span class="hljs-keyword">else</span> (x-i.lo) / (i.hi - i.lo)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">per</span>(<span class="hljs-params">i,p=<span class="hljs-number">.5</span>,lo=<span class="hljs-literal">None</span>,hi=<span class="hljs-literal">None</span></span>):
    <span class="hljs-string">&quot;Query: Return the item that is `p-th` beteeen `lo` and `hi`&quot;</span>
    a  = i.<span class="hljs-built_in">all</span>()
    lo = lo <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
    hi = hi <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(a)
    <span class="hljs-keyword">if</span> hi==<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;?&quot;</span>
    <span class="hljs-keyword">return</span> a[<span class="hljs-built_in">int</span>(lo + p*(hi - lo))]

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">prep</span>(<span class="hljs-params">i,x</span>): 
    <span class="hljs-string">&quot;Creation: Coerce `x` to a float.&quot;</span>
    <span class="hljs-keyword">return</span> x <span class="hljs-keyword">if</span> x==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-built_in">float</span>(x)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">var</span>(<span class="hljs-params">i</span>): 
    <span class="hljs-string">&quot;&quot;&quot;&lt;img align=right width=300 
        src=&quot;https://miro.medium.com/max/1400/1*IZ2II2HYKeoMrdLU5jW6Dw.png&quot;&gt;
    Query: variability.
    As well know,  plus or minus (1,2) sd is (66%,95%) of the area 
    under the normal curve.  Another number of interest is that  plus or 
    minus 1.28 sd is 90% of the mass.  This means that one standard 
    deviation is 90% of the mass divided by (1.28*2)=2.56. Hence,
    to compute something analogous to sd from any distribution, 
    sort it and look at the 90th and 10th percentile. &lt;br clear=all&gt;&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> (i.per(<span class="hljs-number">.9</span>) - i.per(<span class="hljs-number">.1</span>)) / <span class="hljs-number">2.56</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Row</span>(<span class="hljs-title class_ inherited__">o</span>):
  <span class="hljs-string">&quot;Data: store rows&quot;</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">i,lst,sample</span>): 
     i.sample,i.cells, i.ranges = sample, lst,[<span class="hljs-literal">None</span>]*<span class="hljs-built_in">len</span>(lst)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">i,j</span>):
    <span class="hljs-string">&quot;Does row1 win over row2?&quot;</span>
    s1, s2, n = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(i.sample.y)
    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> i.sample.y:
      a   = col.norm(i.cells[col.at])
      b   = col.norm(j.cells[col.at])
      s1 -= math.e**(col.w * (a - b) / n)
      s2 -= math.e**(col.w * (b - a) / n)
    <span class="hljs-keyword">return</span> s1 / n &lt; s2 / n

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">ys</span>(<span class="hljs-params">i</span>):
    <span class="hljs-string">&quot;Query: the goal values of this row&quot;</span>
    <span class="hljs-keyword">return</span> [i.cells[col.at] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> i.sample.y]

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span>(Distance,o):
  <span class="hljs-string">&quot;Data: store rows and columns&quot;</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">i,my, inits=[]</span>): 
    <span class="hljs-string">&quot;Creation&quot;</span>
    i.cols, i.rows, i.x, i.y, i.my = [],[],[],[], my
    [i.row(init) <span class="hljs-keyword">for</span> init <span class="hljs-keyword">in</span> inits]

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">i,j</span>):
    <span class="hljs-string">&quot;Sort tables by their mid values.&quot;</span>
    <span class="hljs-keyword">return</span>  Row(i.mid(),i) &lt; Row(j.mid(), j)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">i,inits=[]</span>):
    <span class="hljs-string">&quot;Copy: return a new sample with same structure as self&quot;</span>
    <span class="hljs-keyword">return</span> Sample(i.my, 
                  inits=[[col.txt <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> i.cols]]+inits)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">header</span>(<span class="hljs-params">i,lst</span>):
    <span class="hljs-string">&quot;Creation: Create columns. Store dependent and independent columns in `x` and `y`&quot;</span>
    <span class="hljs-keyword">for</span> c,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lst):
      what= Skip <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">else</span> (Num <span class="hljs-keyword">if</span> x[<span class="hljs-number">0</span>].isupper() <span class="hljs-keyword">else</span> Sym)
      new = what(i.my,c,x)
      i.cols += [new]
      <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> x:
        what = i.y <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;+&quot;</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">in</span> x <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;!&quot;</span> <span class="hljs-keyword">in</span> x) <span class="hljs-keyword">else</span> i.x
        what += [new]
 
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">i,file</span>): 
    <span class="hljs-string">&quot;Creation: Load data from a csv file in a Data instance.&quot;</span>
    <span class="hljs-keyword">for</span> lst <span class="hljs-keyword">in</span> csv(file): i.row(lst)
    <span class="hljs-keyword">return</span> i

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mid</span>(<span class="hljs-params">i</span>):
    <span class="hljs-string">&quot;Query: report middle&quot;</span>
    <span class="hljs-keyword">return</span> [col.mid() <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> i.cols]
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">row</span>(<span class="hljs-params">i,lst</span>):
    <span class="hljs-string">&quot;&quot;&quot;Update: Turn `lst` into either a `header` (if it is row0) 
    or a `row` (for every other  line).&quot;&quot;&quot;</span>
    lst = lst.cells <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(lst)==Row <span class="hljs-keyword">else</span> lst
    <span class="hljs-keyword">if</span> i.cols: i.rows += [Row([c.add(c.prep(x)) <span class="hljs-keyword">for</span> c,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(i.cols,lst)],i)]
    <span class="hljs-keyword">else</span>: i.header(lst)

  <span class="hljs-keyword">def</span> <span class="hljs-title function_">ys</span>(<span class="hljs-params">i</span>):
    <span class="hljs-string">&quot;Query: report goals&quot;</span>
    <span class="hljs-keyword">return</span> [col.mid() <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> i.y]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">csv</span>(<span class="hljs-params">file, sep=<span class="hljs-string">&quot;,&quot;</span>, dull=<span class="hljs-string">r&#x27;([\n\t\r ]|#.*)&#x27;</span></span>):
  <span class="hljs-string">&quot;Yield lines from comma repeated files, deleting `dull` things.&quot;</span>
  <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file) <span class="hljs-keyword">as</span> fp:
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> fp:
      s=re.sub(dull,<span class="hljs-string">&quot;&quot;</span>,s)
      <span class="hljs-keyword">if</span> s: <span class="hljs-keyword">yield</span> s.split(sep)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">first</span>(<span class="hljs-params">a</span>): 
  <span class="hljs-string">&quot;First item&quot;</span> 
  <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">cli</span>(<span class="hljs-params">usage, <span class="hljs-built_in">dict</span>=CONFIG</span>):
  <span class="hljs-string">&quot;&quot;&quot;
  (1) Execute a command-line parse that uses `dict` keys as  command line  flags
      (so expect `dict` values to be tuples (type, defaultValue,help));   
  (2) Define switches for  defaults that re `False`;    
  (3) If keys repeat, make the  second one upper case.&quot;&quot;&quot;</span>
  p    = argparse.ArgumentParser(prog=usage, description=__doc__, 
                    formatter_class=argparse.RawTextHelpFormatter)
  add  = p.add_argument
  used = {}
  <span class="hljs-keyword">for</span> k, (ako, default, <span class="hljs-built_in">help</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">dict</span>.items()):
    k0 = k[<span class="hljs-number">0</span>]
    k0 = k0.upper() <span class="hljs-keyword">if</span> k0 <span class="hljs-keyword">in</span> used <span class="hljs-keyword">else</span> k0
    c = used[k0] = k0  <span class="hljs-comment"># (3)</span>
    <span class="hljs-keyword">if</span> default == <span class="hljs-literal">False</span>: <span class="hljs-comment"># (2)</span>
      add(<span class="hljs-string">&quot;-&quot;</span>+c, dest=k, default=<span class="hljs-literal">False</span>, <span class="hljs-built_in">help</span>=<span class="hljs-built_in">help</span>, action=<span class="hljs-string">&quot;store_true&quot;</span>)
    <span class="hljs-keyword">else</span>: <span class="hljs-comment"># (1)</span>
      add(<span class="hljs-string">&quot;-&quot;</span>+c, dest=k, default=default, <span class="hljs-built_in">help</span>=<span class="hljs-built_in">help</span> + <span class="hljs-string">&quot; [&quot;</span> + <span class="hljs-built_in">str</span>(default) + <span class="hljs-string">&quot;]&quot;</span>,
          <span class="hljs-built_in">type</span>=<span class="hljs-built_in">type</span>(default), metavar=k)
  <span class="hljs-keyword">return</span> p.parse_args().__dict__

crash = -<span class="hljs-number">1</span> 
<span class="hljs-keyword">def</span> <span class="hljs-title function_">eg</span>(<span class="hljs-params">f</span>):
<span class="hljs-meta">  @wraps(<span class="hljs-params">f</span>)</span>
  <span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>(<span class="hljs-params">my</span>):
    <span class="hljs-keyword">global</span> crash
    random.seed(my.seed)
    <span class="hljs-keyword">if</span> my.todo == f.__name__:
       <span class="hljs-keyword">try</span>: 
         f(my)
         <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\x1b[1;32m✔ <span class="hljs-subst">{f.__name__}</span>\x1b[0m\n&quot;</span>)
       <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err: 
         crash += <span class="hljs-number">1</span>
         <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\x1b[1;31m✘  <span class="hljs-subst">{f.__name__}</span>\x1b[0m\n&quot;</span>)
         <span class="hljs-keyword">if</span> my.loud: <span class="hljs-built_in">print</span>(traceback.format_exc())
  <span class="hljs-keyword">return</span> worker

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">funs</span>):
  <span class="hljs-string">&quot;&quot;&quot;(1) Update the config using any command-line settings.
  (2) Maybe, udpate  `todo` from the  command line.&quot;&quot;&quot;</span>    
  my = o(**cli(<span class="hljs-string">&quot;python3 range.py [OPTIONS]&quot;</span>))
  <span class="hljs-keyword">if</span> my.Todo:
    eg.<span class="hljs-built_in">list</span>(my)
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">if</span> my.todo == <span class="hljs-string">&quot;all&quot;</span>:
      <span class="hljs-keyword">for</span> k,f <span class="hljs-keyword">in</span> <span class="hljs-built_in">vars</span>(eg).items():
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(f) == fun <span class="hljs-keyword">and</span> k[<span class="hljs-number">0</span>] != <span class="hljs-string">&quot;_&quot;</span>:
          do1(my, f)
      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Errors:&quot;</span>,eg.crash)
    <span class="hljs-keyword">else</span>:
      do1(my, <span class="hljs-built_in">vars</span>(eg)[my.todo] <span class="hljs-keyword">if</span> my.todo <span class="hljs-keyword">else</span> todo)</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
